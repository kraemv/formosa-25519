/**
 * function __sub4_rrr
 * @param {reg u64[4]} f - Minuend in 64-bit limb representation
 * @param {reg u64[4]} g - Subtrahend in 64-bit limb representation
 * @returns {reg u64[4]} - Difference of f and g in 64-bit limb representation
 * 
 * This function subtracts g from f. Minuend is consumed.
 * The representation is:
 * h = f - g
 * h = (2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3) -
 *     (2**0*g0 + 2**64*g1 + 2**128*g2 + 2**192*g3)
*/
inline fn __sub4_rrr(reg u64[4] f, reg u64[4] g) -> reg u64[4]
{
  reg u64 z;    // Zero register
  reg bool cf;  // Carry flag
  inline int i;
  
  // Set 0 register
  ?{}, z = #set0();
  
  // Subtract with borrow flag
  cf, f[0] -= g[0];
  for i=1 to 4
  { cf, f[i] -= g[i] - cf; }
  
  /*
  cf = 0 -> No reduce, (z - cf) & 38 = 0 & 38 = 0
  cf = 1 -> Reduce, (z - cf) & 38 = (0xf..f) & 38 = 38
  */
  _, z -= z - cf;
  z &= 38;
  
  // Reduce in const time if cf=1 (subtract 38)
  cf, f[0] -= z;
  for i=1 to 4
  { cf, f[i] -= 0 - cf; }
  
  // Reduce once more if f-g < -2*p
  _, z -= z - cf;
  z &= 38;
  f[0] -= z;

  return f;
}

/**
 * function __sub4_srr
 * @param {reg u64[4]} f - Minuend in 64-bit limb representation
 * @param {reg u64[4]} g - Subtrahend in 64-bit limb representation
 * @returns {stack u64[4]} - Difference of f and g in 64-bit limb representation
 * 
 * This function subtracts g from f. Minuend is consumed.
 * Return value lies on the stack.
 * The representation is:
 * h = f - g
 * h = (2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3) -
 *     (2**0*g0 + 2**64*g1 + 2**128*g2 + 2**192*g3)
*/
inline fn __sub4_srr(reg u64[4] f, reg u64[4] g) -> stack u64[4]
{
  reg u64[4] h;
  stack u64[4] hs;

  h = __sub4_rrr(f, g);
  hs = #copy(h);

  return hs;
}

/**
 * function __sub4_rrs
 * @param {reg u64[4]} f - Minuend in 64-bit limb representation
 * @param {stack u64[4]} g - ptr to subtrahend in 64-bit limb representation
 * @returns {reg u64[4]} - Difference of f and g in 64-bit limb representation
 * 
 * This function subtracts g from f. Inputs are not consumed.
 * The representation is:
 * h = f - g
 * h = (2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3) -
 *     (2**0*g0 + 2**64*g1 + 2**128*g2 + 2**192*g3)
*/
inline fn __sub4_rrs(reg u64[4] f, stack u64[4] gs) -> reg u64[4]
{
  reg u64 z;    // Zero register
  reg u64[4] h; // Result
  reg bool cf;  // Borrow flag
  inline int i;
  
  // Set 0 register
  ?{}, z = #set0();
  
  // Copy f to not consume input
  h = #copy(f);
  
  // Subtract with borrow flag
  cf, h[0] -= gs[0];
  for i=1 to 4
  { cf, h[i] -= gs[i] - cf; }
  
  /*
  cf = 0 -> No reduce, (z - cf) & 38 = 0 & 38 = 0
  cf = 1 -> Reduce, (z - cf) & 38 = (0xf..f) & 38 = 38
  */
  _, z -= z - cf;
  z &= 38;
  
  // Reduce in const time if cf=1 (subtract 38)
  cf, h[0] -= z;
  for i=1 to 4
  { cf, h[i] -= 0 - cf; }
  
  // Reduce once more if f-g < -2*p
  _, z -= z - cf;
  z &= 38;
  h[0] -= z;

  return h;
}

/**
 * function __sub4_rrp
 * @param {reg u64[4]} f - Minuend in 64-bit limb representation
 * @param {reg ptr u64[4]} g - ptr to subtrahend in 64-bit limb representation
 * @returns {reg u64[4]} - Difference of f and g in 64-bit limb representation
 * 
 * This function subtracts g from f. Inputs are not consumed.
 * The representation is:
 * h = f - g
 * h = (2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3) -
 *     (2**0*g0 + 2**64*g1 + 2**128*g2 + 2**192*g3)
*/
inline fn __sub4_rrp(reg u64[4] f, reg ptr u64[4] gs) -> reg u64[4]
{
  reg u64 z;    // Zero register
  reg u64[4] h; // Result
  reg bool cf;  // Borrow flag
  inline int i;
  
  // Set 0 register
  ?{}, z = #set0();
  
  // Copy f to not consume input
  h = #copy(f);
  
  // Subtract with borrow flag
  cf, h[0] -= gs[0];
  for i=1 to 4
  { cf, h[i] -= gs[i] - cf; }
  
  /*
  cf = 0 -> No reduce, (z - cf) & 38 = 0 & 38 = 0
  cf = 1 -> Reduce, (z - cf) & 38 = (0xf..f) & 38 = 38
  */
  _, z -= z - cf;
  z &= 38;
  
  // Reduce in const time if cf=1 (subtract 38)
  cf, h[0] -= z;
  for i=1 to 4
  { cf, h[i] -= 0 - cf; }
  
  // Reduce once more if f-g < -2*p
  _, z -= z - cf;
  z &= 38;
  h[0] -= z;

  return h;
}

/**
 * function __sub4_rsr
 * @param {stack u64[4]} f - ptr to minuend in 64-bit limb representation
 * @param {reg u64[4]} g - Subtrahend in 64-bit limb representation
 * @returns {reg u64[4]} - Difference of f and g in 64-bit limb representation
 * 
 * This function subtracts g from f. Inputs are not consumed.
 * The representation is:
 * h = f - g
 * h = (2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3) -
 *     (2**0*g0 + 2**64*g1 + 2**128*g2 + 2**192*g3)
*/
inline fn __sub4_rsr(stack u64[4] fs, reg u64[4] g) -> reg u64[4]
{
  reg u64 z;    // Zero register
  reg u64[4] h; // Result
  reg bool cf;  // Borrow flag
  inline int i;
  
  // Set 0 register
  ?{}, z = #set0();
  
  // Copy f to not consume input
  h = #copy(fs);
  
  // Subtract with borrow flag
  cf, h[0] -= g[0];
  for i=1 to 4
  { cf, h[i] -= g[i] - cf; }
  
  /*
  cf = 0 -> No reduce, (z - cf) & 38 = 0 & 38 = 0
  cf = 1 -> Reduce, (z - cf) & 38 = (0xf..f) & 38 = 38
  */
  _, z -= z - cf;
  z &= 38;
  
  // Reduce in const time if cf=1 (subtract 38)
  cf, h[0] -= z;
  for i=1 to 4
  { cf, h[i] -= 0 - cf; }
  
  // Reduce once more if f-g < -2*p
  _, z -= z - cf;
  z &= 38;
  h[0] -= z;

  return h;
}

/**
 * function __dec4
 * @param {reg u64[4]} f - input in 64-bit limb representation
 * @returns {reg u64[4]} - input decremented by 1 in 64-bit limb representation
 * 
 * This function decrements the input by 1. The input is consumed:
 * h = f - 1
 * h = 2**0*f0 + 2**64*f1 + 2**128*f2 + 2**192*f3 - 1
*/
inline fn __dec4(reg u64[4] f) -> reg u64[4]
{
  reg u64 z;    // Zero register
  reg bool cf;  // Carry flag
  inline int i;

  // Set 0 register
  ?{}, z = #set0();

  // Add with carry flag
  cf, f[0] -= 1;
  for i=1 to 4
  { cf, f[i] -= z - cf; }
  
  /*
  cf = 0 -> No reduce, (z - cf) & 38 = 0 & 38 = 0
  cf = 1 -> Reduce, (z - cf) & 38 = (0xf..f) & 38 = 38
  */
  _, z -= z - cf;
  z &= 38;

  // Reduce in const time if cf=1 (subtract 38)
  cf, f[0] -= z;

  return f;
}

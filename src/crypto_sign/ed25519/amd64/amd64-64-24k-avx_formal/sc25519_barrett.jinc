require "shared_const.jinc"

abstract predicate bool eqmod(int, int, tuple);
abstract predicate tuple single(int);
abstract predicate tuple quad(u64, u64, u64, u64);
abstract predicate int b2i(bool);
abstract predicate int u64i(u64);
abstract predicate u256 limbs_4u64(tuple);
abstract predicate int pow(int, int);

inline fn __barrett_c0_ghost
( reg u64    x0,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 rax;

	(q[1], q[0]) 		= #MULX ( x0, mu[0] );
	(q[2], rax) 	= #MULX ( x0, mu[1] );
	cf, q[1]   		= #ADCX ( q[1], rax, cf );
	(q[3], rax) 	= #MULX ( x0, mu[2] );
	cf, q[2]   		= #ADCX ( q[2], rax, cf );
	(q[4], rax) 	= #MULX ( x0, mu[3] );
	cf, q[3]   		= #ADCX ( q[3], rax, cf );
	(q[5], rax) 	= #MULX ( x0, mu[4] );
	cf, q[4]   		= #ADCX ( q[4], rax, cf );
	cf, q[5]   		= #ADCX ( q[5], z, cf );
	
	#[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

  return q, cf, of;
}

inline fn __barrett_c1_ghost
( reg u64    x1,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x1, mu[0] );
	of, q[1]		= #ADOX ( q[1], rax, of );
  cf, q[2]		= #ADCX ( q[2], c, cf );
  
	(c, rax) 		= #MULX ( x1, mu[1] );
	of, q[2]    = #ADOX ( q[2], rax, of );
  cf, q[3]    = #ADCX ( q[3], c, cf );
  
  (c, rax) 		= #MULX ( x1, mu[2] );
	of, q[3]    = #ADOX ( q[3], rax, of );
  cf, q[4]    = #ADCX ( q[4], c, cf );
  
  (c, rax) 		= #MULX ( x1, mu[3] );
	of, q[4]    = #ADOX ( q[4], rax, of );
  cf, q[5]    = #ADCX ( q[5], c, cf );
  
	(q[6], rax)	= #MULX ( x1, mu[4] );
	of, q[5]   	= #ADOX ( q[5], rax, of );
	
	cf, q[6]   	= #ADCX ( q[6], z, cf );
	of, q[6]   	= #ADOX ( q[6], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c2_ghost
( reg u64    x2,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x2, mu[0] );
	of, q[2]    = #ADOX ( q[2], rax, of );
  cf, q[3]    = #ADCX ( q[3], c, cf );
  
  (c, rax) 		= #MULX ( x2, mu[1] );
	of, q[3]    = #ADOX ( q[3], rax, of );
  cf, q[4]    = #ADCX ( q[4], c, cf );
  
	(c, rax) 		= #MULX ( x2, mu[2] );
	of, q[4]    = #ADOX ( q[4], rax, of );
  cf, q[5]    = #ADCX ( q[5], c, cf );
  
  (c, rax) 		= #MULX ( x2, mu[3] );
	of, q[5]    = #ADOX ( q[5], rax, of );
  cf, q[6]    = #ADCX ( q[6], c, cf );
  
	(q[7], rax) = #MULX ( x2, mu[4] );
	of, q[6]   	= #ADOX ( q[6], rax, of );
	
	cf, q[7]   	= #ADCX ( q[7], z, cf );
	of, q[7]   	= #ADOX ( q[7], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c3_ghost
( reg u64    x3,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x3, mu[0] );
	of, q[3]    = #ADOX ( q[3], rax, of );
  cf, q[4]    = #ADCX ( q[4], c, cf );
  
	(c, rax) 		= #MULX ( x3, mu[1] );
	of, q[4]    = #ADOX ( q[4], rax, of );
  cf, q[5]    = #ADCX ( q[5], c, cf );
  
	(c, rax) 		= #MULX ( x3, mu[2] );
	of, q[5]    = #ADOX ( q[5], rax, of );
  cf, q[6]    = #ADCX ( q[6], c, cf );
  
  /*of, q[6]   	= #ADOX ( q[6], z, of );
  of, q[7]   	= #ADOX ( q[7], z, of );
	cf, q[7]   	= #ADCX ( q[7], z, cf );*/
  
  (c, rax) 		= #MULX ( x3, mu[3] );
	of, q[6]    = #ADOX ( q[6], rax, of );
  cf, q[7]    = #ADCX ( q[7], c, cf );
  
	(q[8], rax) = #MULX ( x3, mu[4] );
	of, q[7]   	= #ADOX ( q[7], rax, of );
	
	cf, q[8]   	= #ADCX ( q[8], z, cf );
	of, q[8]   	= #ADOX ( q[8], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c4_ghost
( reg u64    x4,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x4, mu[0] );
	of, q[4]    = #ADOX ( q[4], rax, of );
  cf, q[5]    = #ADCX ( q[5], c, cf );
  
	(c, rax) 		= #MULX ( x4, mu[1] );
	of, q[5]    = #ADOX ( q[5], rax, of );
  cf, q[6]    = #ADCX ( q[6], c, cf );
  
  /*of, q[6]   	= #ADOX ( q[6], z, of );
  of, q[7]   	= #ADOX ( q[7], z, of );
	cf, q[7]   	= #ADCX ( q[7], z, cf );*/
  
	(c, rax) 		= #MULX ( x4, mu[2] );
	of, q[6]    = #ADOX ( q[6], rax, of );
  cf, q[7]    = #ADCX ( q[7], c, cf );
  
  (c, rax) 		= #MULX ( x4, mu[3] );
	of, q[7]    = #ADOX ( q[7], rax, of );
  cf, q[8]    = #ADCX ( q[8], c, cf );
  
	(q[9], rax) = #MULX ( x4, mu[4] );
	of, q[8]   	= #ADOX ( q[8], rax, of );
	
	cf, q[9]   	= #ADCX ( q[9], z, cf );
	of, q[9]   	= #ADOX ( q[9], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c5_ghost
( reg u64    x5,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x5, mu[0] );
	of, q[5]    = #ADOX ( q[5], rax, of );
  cf, q[6]    = #ADCX ( q[6], c, cf );
  
  /*of, q[6]   	= #ADOX ( q[6], z, of );
  of, q[7]   	= #ADOX ( q[7], z, of );
	cf, q[7]   	= #ADCX ( q[7], z, cf );*/
  
	(c, rax) 		= #MULX ( x5, mu[1] );
	of, q[6]    = #ADOX ( q[6], rax, of );
  cf, q[7]    = #ADCX ( q[7], c, cf );
  
	(c, rax) 		= #MULX ( x5, mu[2] );
	of, q[7]    = #ADOX ( q[7], rax, of );
  cf, q[8]    = #ADCX ( q[8], c, cf );
  
  (c, rax) 		= #MULX ( x5, mu[3] );
	of, q[8]    = #ADOX ( q[8], rax, of );
  cf, q[9]    = #ADCX ( q[9], c, cf );
  
	(q[10], rax)= #MULX ( x5, mu[4] );
	of, q[9]   	= #ADOX ( q[9], rax, of );
	
	cf, q[10]   = #ADCX ( q[10], z, cf );
	of, q[10]   = #ADOX ( q[10], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c6_ghost
( reg u64    x6,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x6, mu[0] );
	of, q[6]    = #ADOX ( q[6], rax, of );
  cf, q[7]    = #ADCX ( q[7], c, cf );
  
	(c, rax) 		= #MULX ( x6, mu[1] );
	of, q[7]    = #ADOX ( q[7], rax, of );
  cf, q[8]    = #ADCX ( q[8], c, cf );
  
	(c, rax) 		= #MULX ( x6, mu[2] );
	of, q[8]    = #ADOX ( q[8], rax, of );
  cf, q[9]    = #ADCX ( q[9], c, cf );
  
  (c, rax) 		= #MULX ( x6, mu[3] );
	of, q[9]    = #ADOX ( q[9], rax, of );
  cf, q[10]   = #ADCX ( q[10], c, cf );
  
	(q[11], rax)= #MULX ( x6, mu[4] );
	of, q[10]   = #ADOX ( q[10], rax, of );
	
	cf, q[11]   = #ADCX ( q[11], z, cf );
	of, q[11]   = #ADOX ( q[11], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c7_ghost
( reg u64    x7,
  reg u64[12] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[12],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x7, mu[0] );
	of, q[7]    = #ADOX ( q[7], rax, of );
  cf, q[8]    = #ADCX ( q[8], c, cf );
  
	(c, rax) 		= #MULX ( x7, mu[1] );
	of, q[8]    = #ADOX ( q[8], rax, of );
  cf, q[9]    = #ADCX ( q[9], c, cf );
  
	(c, rax) 		= #MULX ( x7, mu[2] );
	of, q[9]    = #ADOX ( q[9], rax, of );
  cf, q[10]   = #ADCX ( q[10], c, cf );
  
  (c, rax) 		= #MULX ( x7, mu[3] );
	of, q[10]   = #ADOX ( q[10], rax, of );
  cf, q[11]   = #ADCX ( q[11], c, cf );
  
	(c, rax) = #MULX ( x7, mu[4] );
	of, q[11]   = #ADOX ( q[11], rax, of );
	
	cf, c   		= #ADCX ( c, z, cf );
	of, c   		= #ADOX ( c, z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c3
( reg u64    x3,
  reg u64[6] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[6],
  reg bool,
  reg bool
{
  reg u64 c;

	(c, q[0]) 		= #MULX ( x3, mu[3] );
	(q[2], q[1]) 	= #MULX ( x3, mu[4] );
	cf, q[1]   		= #ADCX ( q[1], c, cf );
	cf, q[2]   		= #ADCX ( q[2], z, cf );
	
	#[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

  return q, cf, of;
}

inline fn __barrett_c4
( reg u64    x4,
  reg u64[6] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[6],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x4, mu[2] );
	of, q[0]		= #ADOX ( q[0], rax, of );
  cf, q[1]		= #ADCX ( q[1], c, cf );
  
	(c, rax) 		= #MULX ( x4, mu[3] );
	of, q[1]    = #ADOX ( q[1], rax, of );
  cf, q[2]    = #ADCX ( q[2], c, cf );
  
	(q[3], rax)	= #MULX ( x4, mu[4] );
	of, q[2]   	= #ADOX ( q[2], rax, of );
	
	cf, q[3]   	= #ADCX ( q[3], z, cf );
	of, q[3]   	= #ADOX ( q[3], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c5
( reg u64    x5,
  reg u64[6] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[6],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x5, mu[1] );
	of, q[0]    = #ADOX ( q[0], rax, of );
  cf, q[1]    = #ADCX ( q[1], c, cf );
  
	(c, rax) 		= #MULX ( x5, mu[2] );
	of, q[1]    = #ADOX ( q[1], rax, of );
  cf, q[2]    = #ADCX ( q[2], c, cf );
  
  (c, rax) 		= #MULX ( x5, mu[3] );
	of, q[2]    = #ADOX ( q[2], rax, of );
  cf, q[3]    = #ADCX ( q[3], c, cf );
  
	(q[4], rax) = #MULX ( x5, mu[4] );
	of, q[3]   	= #ADOX ( q[3], rax, of );
	
	cf, q[4]   	= #ADCX ( q[4], z, cf );
	of, q[4]   	= #ADOX ( q[4], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c6
( reg u64    x6,
  reg u64[6] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[6],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x6, mu[0] );
	of, q[0]    = #ADOX ( q[0], rax, of );
  cf, q[1]    = #ADCX ( q[1], c, cf );
  
	(c, rax) 		= #MULX ( x6, mu[1] );
	of, q[1]    = #ADOX ( q[1], rax, of );
  cf, q[2]    = #ADCX ( q[2], c, cf );
  
  (c, rax) 		= #MULX ( x6, mu[2] );
	of, q[2]    = #ADOX ( q[2], rax, of );
  cf, q[3]    = #ADCX ( q[3], c, cf );
  
  (c, rax) 		= #MULX ( x6, mu[3] );
	of, q[3]    = #ADOX ( q[3], rax, of );
  cf, q[4]    = #ADCX ( q[4], c, cf );
  
	(q[5], rax) = #MULX ( x6, mu[4] );
	of, q[4]   	= #ADOX ( q[4], rax, of );
	
	cf, q[5]   	= #ADCX ( q[5], z, cf );
	of, q[5]   	= #ADOX ( q[5], z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __barrett_c7
( reg u64    x7,
  reg u64[6] q,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[6],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax) 		= #MULX ( x7, mu[0] );
	of, q[1]    = #ADOX ( q[1], rax, of );
  cf, q[2]    = #ADCX ( q[2], c, cf );
  
	(c, rax) 		= #MULX ( x7, mu[1] );
	of, q[2]    = #ADOX ( q[2], rax, of );
  cf, q[3]    = #ADCX ( q[3], c, cf );
  
  (c, rax) 		= #MULX ( x7, mu[2] );
	of, q[3]    = #ADOX ( q[3], rax, of );
  cf, q[4]    = #ADCX ( q[4], c, cf );
  
  (c, rax) 		= #MULX ( x7, mu[3] );
	of, q[4]    = #ADOX ( q[4], rax, of );
  cf, q[5]    = #ADCX ( q[5], c, cf );
  
	(c, rax) = #MULX ( x7, mu[4] );
	of, q[5]   	= #ADOX ( q[5], rax, of );
	
	cf, c   	= #ADCX ( c, z, cf );
	of, c   	= #ADOX ( c, z, of );

  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  #[kind=Assert, prover=smt] assert (!of);
  #[kind=Assume, prover=cas] assert (b2i(of) == 0);
  
  return q, cf, of;
}

inline fn __mulL_c0
( reg u64    q0,
  reg u64[4] r2,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[4],
  reg bool,
  reg bool
{
  reg u64 c rax;
  
	(r2[1], r2[0])	= #MULX ( q0, L[0] );
	(r2[2], rax) 		= #MULX ( q0, L[1] );
  cf, r2[1]   		= #ADCX ( r2[1], rax, cf );
  
  (r2[3], rax) 		= #MULX ( q0, L[2] );
  cf, r2[2]   		= #ADCX ( r2[2], rax, cf );
  
  (c, rax) 				= #MULX ( q0, L[3] );
  cf, r2[3]   		= #ADCX ( r2[3], rax, cf );
  
  #[kind=Assert, prover=smt] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);

  return r2, cf, of;
}

inline fn __mulL_c1
( reg u64    q1,
  reg u64[4] r2,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[4],
  reg bool,
  reg bool
{
  reg u64 c rax;

	(c, rax)		= #MULX ( q1, L[0] );
	of, r2[1]		= #ADOX ( r2[1], rax, of );
  cf, r2[2]		= #ADCX ( r2[2], c, cf );
  
  (c, rax)		= #MULX ( q1, L[1] );
	of, r2[2]		= #ADOX ( r2[2], rax, of );
  cf, r2[3]		= #ADCX ( r2[3], c, cf );
  
  (c, rax)		= #MULX ( q1, L[2] );
	of, r2[3]		= #ADOX ( r2[3], rax, of );

  return r2, cf, of;
}

inline fn __mulL_c2
( reg u64    q2,
  reg u64[4] r2,
  reg u64    z, // zero
  reg bool   cf of // cf = 0 and of = 0
  ) ->
  reg u64[4],
  reg bool,
  reg bool
{
  reg u64 c rax;
	(c, rax)		= #MULX ( q2, L[0] );
	of, r2[2]		= #ADOX ( r2[2], rax, of );
  cf, r2[3]		= #ADCX ( r2[3], c, cf );
  
  (c, rax)		= #MULX ( q2, L[1] );
	of, r2[3]		= #ADOX ( r2[3], rax, of );

  return r2, cf, of;
}

fn sc25519_barrett(reg u64[8] x) -> reg u64[4]
	ensures #[prover=cas] {
  eqmod (
     \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(result.0[ii])),
     \sum (ii \in 0:8) (pow(2, 64*ii)*u64i(x[ii])),
     single((pow(2,252)) + 27742317777372353535851937790883648493)
    )
  }
{
	reg u64 z rax rdx c;
	reg u64[4] r r2 t;
	reg u64[6] q;
	stack u64[4] q3s;
	reg bool cf of;
	inline int i;
	
	?{CF=cf, OF=of}, z = #set0();
	
	// Multiply with mu
	// Multiply 3rd limb
	rdx = x[3];
	q, cf, of = __barrett_c3(rdx, q, z, cf, of);
	
	// Multiply 4th limb
	rdx = x[4];
	q, cf, of = __barrett_c4(rdx, q, z, cf, of);
	
	// Multiply 5th limb
	rdx = x[5];
	q, cf, of = __barrett_c5(rdx, q, z, cf, of);
	
	// Multiply 6th limb
	rdx = x[6];
	q, cf, of = __barrett_c6(rdx, q, z, cf, of);
	
	// Multiply 7th limb
	rdx = x[7];
	q, cf, of = __barrett_c7(rdx, q, z, cf, of);
	
	for i=0 to 4{
		q3s[i] = q[2+i];
	}
	
	// Multiply with L for final reduction
	// First limb
	rdx = q3s[0];
	r2, cf, of = __mulL_c0(rdx, r2, z, cf, of);
	
	// Second limb
	rdx = q3s[1];
	r2, cf, of = __mulL_c1(rdx, r2, z, cf, of);
	
	// Third limb
	?{CF=cf, OF=of}, z = #set0();
	rdx = q3s[2];
	r2, cf, of = __mulL_c2(rdx, r2, z, cf, of);
	
	rax = q3s[3];
	rdx, rax = rax * L[0];
	cf, r2[3] += rax;
	
	r[0] = x[0];
	cf, r[0] -= r2[0];
	t[0] = r[0];
	
	for i=1 to 4
	{
		r[i] = x[i];
		cf, r[i] -= r2[i] - cf;
		t[i] = r[i];
	}
	
	// Should be correct from here on
	cf, t[0] -= L[0];
	cf, t[1] -= L[1] - cf;
	cf, t[2] -= L[2] - cf;
	cf, t[3] -= L[3] - cf;
	
	for i=0 to 4
	{
		r[i] = #CMOVcc(!cf, t[i], r[i]);
		t[i] = r[i];
	}
	
	cf, t[0] -= L[0];
	cf, t[1] -= L[1] - cf;
	cf, t[2] -= L[2] - cf;
	cf, t[3] -= L[3] - cf;
	
	for i=0 to 4
	{
		r[i] = #CMOVcc(!cf, t[i], r[i]);
	}
	
	return r;
}

fn sc25519_barrett_p(reg ptr u64[8] x) -> reg u64[4]
	/*ensures #[prover=smt] {
     limbs_4u64(quad(result.0[0], result.0[1], result.0[2], result.0[3])) < 0x1000000000000000000000000000000014DEF9DEA2F79CD65812631A5CF5D3ED
  }*/
  
	ensures #[prover=cas] {
  eqmod (
     \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(result.0[ii])),
     \sum (ii \in 0:8) (pow(2, 64*ii)*u64i(x[ii])),
     single((pow(2,252)) + 27742317777372353535851937790883648493)
    )
  }
{
	reg u64 z rax rdx c;
	reg u64[4] r r2 t t2;
	reg u64[6] q;
	reg u64[12] q_ghost;
	stack u64[4] q3s;
	reg bool cf of;
	inline int i;
	
	?{CF=cf, OF=of}, z = #set0();
	for i=0 to 6{
		?{}, q[i] = #set0();
	}
	for i=0 to 12{
		?{}, q_ghost[i] = #set0();
	}
	
	// Ghost multiply with mu
	// Multiply 0th limb
	rdx = x[0];
	q_ghost, cf, of = __barrett_c0_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 1st limb
	rdx = x[1];
	q_ghost, cf, of = __barrett_c1_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 2nd limb
	rdx = x[2];
	q_ghost, cf, of = __barrett_c2_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 3rd limb
	rdx = x[3];
	q_ghost, cf, of = __barrett_c3_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 4th limb
	rdx = x[4];
	q_ghost, cf, of = __barrett_c4_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 5th limb
	rdx = x[5];
	q_ghost, cf, of = __barrett_c5_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 6th limb
	rdx = x[6];
	q_ghost, cf, of = __barrett_c6_ghost(rdx, q_ghost, z, cf, of);
	
	// Multiply 7th limb
	rdx = x[7];
	q_ghost, cf, of = __barrett_c7_ghost(rdx, q_ghost, z, cf, of);
	
	#[kind=Assert, prover=cas] assert (
  	eqmod (
     \sum (ii \in 0:12) (pow(2, 64*ii)*u64i(q_ghost[ii])),
     (\sum (ii \in 0:8) (pow(2, 64*ii)*u64i(x[ii]))) * (\sum (ii \in 0:5) (pow(2, 64*ii)*u64i(mu[ii]))),
     single(pow(2,768))
    )
  );
  
	// Multiply with mu
	// Multiply 3rd limb
	rdx = x[3];
	q, cf, of = __barrett_c3(rdx, q, z, cf, of);
	
	// Multiply 4th limb
	rdx = x[4];
	q, cf, of = __barrett_c4(rdx, q, z, cf, of);
	
	// Multiply 5th limb
	rdx = x[5];
	q, cf, of = __barrett_c5(rdx, q, z, cf, of);
	
	// Multiply 6th limb
	rdx = x[6];
	q, cf, of = __barrett_c6(rdx, q, z, cf, of);
	
	// Multiply 7th limb
	rdx = x[7];
	q, cf, of = __barrett_c7(rdx, q, z, cf, of);
  
	for i=0 to 4{
		q3s[i] = q[2+i];
	}
  
  cf, q_ghost[8] -= q3s[0];
  cf, q_ghost[9] -= q3s[1] - cf;
  cf, q_ghost[10] -= q3s[2] - cf;
  cf, q_ghost[11] -= q3s[3] - cf;
  
  #[kind=Assert, prover=cas] assert (!cf);
  #[kind=Assume, prover=cas] assert (b2i(cf) == 0);
  
	// Multiply with L for final reduction
	// First limb
	rdx = q3s[0];
	r2, cf, of = __mulL_c0(rdx, r2, z, cf, of);
	
	// Second limb
	rdx = q3s[1];
	r2, cf, of = __mulL_c1(rdx, r2, z, cf, of);
	
	// Third limb
	?{CF=cf, OF=of}, z = #set0();
	rdx = q3s[2];
	r2, cf, of = __mulL_c2(rdx, r2, z, cf, of);
	
	rax = q3s[3];
	rdx, rax = rax * L[0];
	
	cf, r2[3] += rax;
	
  #[kind=Assert, prover=cas] assert (
    eqmod (
			(\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(q3s[ii]))) * (\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(L[ii]))),
		  \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(r2[ii])),
		  single((pow(2,256)))
    )
  );
  
	r[0] = x[0];
	cf, r[0] -= r2[0];
	t[0] = r[0];
	
	for i=1 to 4
	{
		r[i] = x[i];
		cf, r[i] -= r2[i] - cf;
		t[i] = r[i];
	}
	
	t2 = #copy(r);
	
	/*#[kind=Assert, prover=smt] assert (
     limbs_4u64(quad(r[0], r[1], r[2], r[3])) < 3 * 0x1000000000000000000000000000000014DEF9DEA2F79CD65812631A5CF5D3ED
  );*/
	#[kind=Assert, prover=cas] assert (
    eqmod (
			(\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(x[ii]))) - (\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(q3s[ii]))) * (\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(L[ii]))),
		  \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(r[ii])),
		  single((pow(2,256)))
    )
  );
	
	cf, t[0] -= L[0];
	cf, t[1] -= L[1] - cf;
	cf, t[2] -= L[2] - cf;
	cf, t[3] -= L[3] - cf;
	
	for i=0 to 4
	{
		r[i] = #CMOVcc(!cf, t[i], r[i]);
		t[i] = r[i];
	}
	
	cf, t[0] -= L[0];
	cf, t[1] -= L[1] - cf;
	cf, t[2] -= L[2] - cf;
	cf, t[3] -= L[3] - cf;
	
	for i=0 to 4
	{
		r[i] = #CMOVcc(!cf, t[i], r[i]);
	}
	#[kind=Assert, prover=cas] assert (
    eqmod (
			\sum (ii \in 0:4) (pow(2, 64*ii)*u64i(t2[ii])),
		  \sum (ii \in 0:4) (pow(2, 64*ii)*u64i(r[ii])),
		  single((pow(2,252)) + 27742317777372353535851937790883648493)
    )
  );
	
	return r;
}

require "shared_const.jinc"

require "../common/load_store4.jinc"
require "../common/decode_scalar.jinc"

require "sha512_api.jinc"
require "curve25519.jinc"
require "sc25519_barrett.jinc"
require "sc25519_add.jinc"
require "sc25519_mul.jinc"
require "mGnP.jinc"

/**
 * function jade_ed25519_amd64_keygen
 * @param {reg} skp - pointer to secret key result
 * @param {reg} pkp - pointer to public key result
 * @returns {reg} - Always return 0 to indicate success
 * 
 * This function samples a secret key sk and computes
 * the corresponding public key pk.
 * The secret key in skp is [sk, pk], the public key is [pk].
*/
#[sct="transient * transient -> public"]
export fn jade_ed25519_amd64_keygen(reg u64 skp pkp) -> reg u64
{
  reg u64 r;            // Result
  reg u64[4] h_red pk;  // Reduced hash, public key
  reg u64[8] h;         // Hash
  reg u256 v_256;       // AVX2 register for load/stores
  stack u64[4] ks;      // Secret scalar
  stack u64[8] H;       // Hash
  stack u64[25] state;  // SHA-512 iterative state
  stack u256[1] sks;    // Secret scalar (stack)
  #msf reg u64 msf;
  
  // Move pointers to avoid register allocation problems
  () = #spill(pkp);
  skp = skp;
	
	// Sample random key
  sks = #randombytes(sks);
	
	// Initialize MSF to prevent cache leakage
	msf = #init_msf();
	
	// Use AVX instructions to store secret scalar in secret key pointer
	v_256 = #VMOVDQA_256(sks[0]);
  [:u256 skp] = v_256;
  // Increase skp by 32bytes to store public key next
  skp += 8*4;
  () = #spill(skp);
  
  // Compute public key scalar by hashing the public key
  // Initialize the sha512 iterative API buffer
	state = sha512_init(state);
	// Write sk to the buffer
	state[:u256 0] =  #VMOVDQA_256(v_256);
	// Set buffer length to 32
	state[24] = 32;
  
  // Compute the hash of the secret key
	#update_after_call
	H, msf = sha512_finalize(state, H, msf);
	h = #copy(H);
	
	// Ed25519 secret scalar clamping
  ks = __decode_scalar(h);
  h_red = #copy(ks);
  
  // Compute public key k*G
  #update_after_call
  pk, msf = _curve25519_mulx_base(h_red, msf);
  
  // Store public key in public and secret key
  () = #unspill(pkp);
  pkp = #protect(pkp, msf);
  __store4(pkp, pk);
  
  () = #unspill(skp);
  skp = #protect(skp, msf);
  __store4(skp, pk);
  
	// Set return status to 0 (success)
  ?{}, r = #set0();
  return r;
}

/**
 * function jade_ed25519_amd64_pubkey
 * @param {reg} skp - pointer to secret key
 * @param {reg} pkp - pointer to public key result
 * @returns {reg} - Always return 0 to indicate success
 * 
 * This function computes the corresponding public key pk
 * for the secret key sk.
*/
#[sct="transient * transient -> public"]
export fn jade_ed25519_amd64_pubkey(reg u64 skp pkp) -> reg u64
{
	reg u64 r;            // Result
	reg u64[4] h_red pk;  // Reduced hash, public key
	reg u64[8] h;         // Hash
	reg u256 v_256;       // AVX2 register for load/stores
	stack u64[4] ks;      // Secret scalar
	stack u64[8] H;       // Hash
  stack u64[25] state;  // SHA-512 iterative state
	#msf reg u64 msf;
	
	// Initialize MSF to prevent cache leakage
	msf = #init_msf();
	() = #spill(pkp);
	
	// Initialize SHA state
	state = sha512_init(state);
	
	// Load secret scalar into hash buffer
	v_256 = [:u256 skp];
	state[:u256 0] = #VMOVDQA_256(v_256);
	// Set the length of read data to 32
	state[24] = 32;
  
  // Compute the hash of the secret scalar
	#update_after_call
	H, msf = sha512_finalize(state, H, msf);
	h = #copy(H);
	
	// Ed25519 secret scalar clamping
  ks = __decode_scalar(h);
  h_red = #copy(ks);
  
  // Compute public key k*G
  #update_after_call
  pk, msf = _curve25519_mulx_base(h_red, msf);
  
  // Store public key
  () = #unspill(pkp);
  pkp = #protect(pkp, msf);
  __store4(pkp, pk);
  
  // Set return status to 0 (success)
  ?{}, r = #set0();
  return r;
}

/**
 * function jade_ed25519_amd64_sign
 * @param {reg} skp - pointer to secret key
 * @param {reg} mp - pointer to message
 * @param {reg} msg_len - length of the message
 * @param {reg} sigp - pointer to signature result
 * @returns {reg} - Always return 0 to indicate success
 * 
 * This function computes the signature (R,s) for the message m
 * with length msg_len for the secret key sk.
*/
#[sct="transient * transient * transient * transient -> public"]
export fn jade_ed25519_amd64_sign(reg u64 skp mp msg_len sigp) -> reg u64
{
  reg u64 r;          // Result
  reg u64[4] h_red;   // reduced hash
  reg u64[4] R s;     // signature: point R, scalar s
  reg u64[8] h;       // hash
  reg u256 h_256;     // prefix
  reg u256 v_256;     // AVX2 register for load/stores
  stack u64 mps;      // Message pointer (spilled)
  stack u64[4] rs ks; // ephemeral r, secret scalar
  stack u64[8] H;     // Hash
  stack u64[25] state state_2;  // SHA-512 iterative states
	#msf reg u64 msf;
	#mmx reg u64 msf_s;
	
	// Initialize MSF to prevent cache leakage
	msf = #init_msf();
	() = #spill(msg_len, sigp);
	mps = mp;
  
  // Initialize SHA state
	state = sha512_init(state);
	state_2 = sha512_init(state_2);
	
	// Load the secret key for secret scalar and prefix
	v_256 = [:u256 skp];
	state[:u256 0] = #VMOVDQA_256(v_256);
	// Set the length of read data to 32
	state[24] = 32;
  
  // Write the public key A to H(R,A,m)
  v_256 = [:u256 (skp + 32)];
	state_2[:u256 1] = #VMOVDQA_256(v_256);
  
  // Hash the secret key
	#update_after_call
	H, msf = sha512_finalize(state, H, msf);
	h = #copy(H);
	
	// Ed25519 secret scalar clamping
  ks = __decode_scalar(h);
  
  // Initialize SHA state
	state = sha512_init(state);
	
	// Compute H(prefix, m)
	h_256 = #VMOVDQA_256(H[:u256 1]);
	state[:u256 0] = #VMOVDQA_256(h_256);
	state[24] = 32;
  
  // Digest the message
  () = #unspill(msg_len);
  mp = mps;
  mp = #protect(mp, msf);
	#update_after_call
  state, msf = sha512_update_ext(state, mp, msg_len, msf);
  () = #spill(mp);
  
  // Obtain the ephemeral scalar r
	#update_after_call
	H, msf = sha512_finalize(state, H, msf);
  
  // Reduce to curve order and compute commitment R
  msf_s = #mov_msf(msf);
  h_red = sc25519_barrett(H);
  rs = #copy(h_red);
  msf = #mov_msf(msf_s);
  #update_after_call
  R, msf = _curve25519_mulx_base(h_red, msf);
  
  // Store R in the signature
  () = #unspill(sigp);
  sigp = #protect(sigp, msf);
  __store4(sigp, R);
  sigp += 8*4;
  () = #spill(sigp);
	
	// Write R to the hash buffer
	state_2[0] = R[0];
	state_2[1] = R[1];
	state_2[2] = R[2];
	state_2[3] = R[3];
	// Length of R+A is 64
	state_2[24] = 64;
	
	// Compute H(R,A,m)
  () = #unspill(msg_len);
  mp = mps;
  mp = #protect(mp, msf);
	#update_after_call
  state_2, msf = sha512_update_ext(state_2, mp, msg_len, msf);
	#update_after_call
	H, msf = sha512_finalize(state_2, H, msf);
	
	// Reduce to curve order
  msf_s = #mov_msf(msf);
  h_red = sc25519_barrett(H);
	
	// Compute the scalar k*H(R,A,m)+r
	s = sc25519_mul_rsr(ks, h_red);
	s = sc25519_add_rrs(s, rs);
	msf = #mov_msf(msf_s);
	
	// Store the scalar
	() = #unspill(sigp);
	sigp = #protect(sigp, msf);
  __store4(sigp, s);
  
  // Set return status to 0 (success)
  ?{}, r = #set0();
  return r;
}

/**
 * function jade_ed25519_amd64_verify
 * @param {reg} sigp - pointer to signature
 * @param {reg} pkp - pointer to public key
 * @param {reg} mp - pointer to message
 * @param {reg} msg_len - length of the message
 * @returns {reg} - Returns 0 for valid signature, else 1
 * 
 * This function validates the signature (R,s) for the message m
 * with length msg_len for the public key pk.
*/
#[sct="transient * transient * transient * transient -> public"]
export fn jade_ed25519_amd64_verify(reg u64 sigp pkp mp msg_len) -> reg u64
{
  reg u64 vrfy_res valid z;   // Result, constant zero
  reg u64[4] s;             // Signature scalar s
  reg u256 A_256 R_256;     // AVX2 registers with public key, commitment
  stack u64[4] R_check;     // value of R for a valid signature + valid byte
  stack u64[4] R A;         // Public key, commitment
  stack u64[8] H;           // Hash
  stack u64[25] state;      // SHA-512 iterative state
  reg bool neq;
  inline int i;
  
  #msf reg u64 msf;
  #mmx reg u64 msf_s;
  
  // Initialize MSF to prevent cache leakage
  msf = #init_msf();
  () = #spill(msg_len, mp, sigp);
  
  // Load public key and commitment
  #declassify A_256 = [:u256 pkp];
  #declassify R_256 = [:u256 sigp];
  
  A[:u256 0] = A_256;
  R[:u256 0] = R_256;
  
  // Initialize SHA state
	state = sha512_init(state);
  
  // Write R, A to H(R,A,m)
  state[:u256 0] = R_256;	
	state[:u256 1] = A_256;
	state[24] = 64;
	
	// Hash m to compute H(R,A,m)
  () = #unspill(msg_len, mp);
  mp = #protect(mp, msf);
  #update_after_call
  state, msf = sha512_update_ext(state, mp, msg_len, msf);
	
	#update_after_call
	#declassify H, msf = sha512_finalize(state, H, msf);
  msf_s = #mov_msf(msf);
  
  // Load the scalar s
  () = #unspill(sigp);
  sigp = #protect(sigp, msf);
  for i=0 to 4
	{
		#declassify s[i] = [sigp + 32 + 8*i];
	}
	
	// Declassify public values for the sct checker
	#declassify R_check = R_check;
	#declassify s = #copy(s);
	#declassify A = A;
	
	// Compute s*G - H(R,A,m)*A
	// Check validity of the signature (point on curve, in range...) in byte 33
	#update_after_call
	R_check, valid, msf = mGnP(R_check, s, H, A, msf);
  
  // Compare provided R against computed R
  // If neq, at least one bit differed and the signature is invalid
  ?{}, z = #set0();
  neq = __cmp4_bss(R_check, R);
	valid = #CMOVcc(!neq, valid, z);
	
	// Invert result (valid signature returns 0)
	#declassify vrfy_res = valid - 1;
	vrfy_res = #protect(vrfy_res, msf);
	
  return vrfy_res;
}

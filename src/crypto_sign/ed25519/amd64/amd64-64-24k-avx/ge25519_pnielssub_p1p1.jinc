require "shared_const.jinc"
require "../common/64/add4.jinc"
require "../common/64/add5.jinc"
require "../common/64/sub4.jinc"
require "../common/64/sub5.jinc"

require "mul5.jinc"

/**
 * function ge25519_pnielssub_p1p1
 * @param {stack u64[18]} pp - Point in extended representation
 * @param {reg ptr u64[16]} qp - Pointer to point in projective representation
 * @returns {stack u64[16]} - Result point in extended intermediate representation
 * 
 * This function computes p-q. The first input is in extended coordinates(x,y,z,t).
 * x,y are 5 limbs large. The second input is in projective niels coordinates(y-x,x+y,z,t*2*d).
 * The output is in intermediate coordinates (e,f,g,h).
 * e = (p.Y + p.X) * (q.Y - q.X) - (p.Y - p.X) * (q.X + q.Y)
 * f = 2*p.Z*q.Z + 2 * d * q.T * p.T
 * g = (p.Y + p.X) * (q.Y - q.X) + (p.Y - p.X) * (q.X + q.Y)
 * h = 2*p.Z*q.Z - 2 * d * q.T * p.T
*/
inline fn ge25519_pnielssub_p1p1(stack u64[18] pp, reg ptr u64[16] qp) -> stack u64[16]
{
	reg u64[5] a b e f g h;
	stack u64[4] as bs;
	stack u64[5] as5 cs5;
	stack u64[16] t;
	reg bool cf;
	inline int i;
	
	// a,b = p.Y
	for i=0 to 5
	{	a[i] = pp[5+i]; }
	b = #copy(a);
	
	// a = p.Y - p.X
	as = __sub5_srs(a, pp[0:5]);
	// b = p.Y + p.X
	bs = __add5_srs(b, pp[0:5]);
	
	// a = (p.Y - p.X) * (q.X + q.Y)
	as5 = __mul5_sp16s_y(qp, as);
	// b,c = (p.Y + p.X) * (q.Y - q.X)
	e = __mul5_rp16s_x(qp, bs);
	g = #copy(e);
	
	// e = (p.Y + p.X) * (q.Y - q.X) - (p.Y - p.X) * (q.X + q.Y)
	t[0:4] = __sub5_srs(e, as5);
	// g = (p.Y + p.X) * (q.Y - q.X) + (p.Y - p.X) * (q.X + q.Y)
	t[8:4] = __add5_srs(g, as5);
	
	// c = 2 * d * q.T * p.T
	cs5 = __mul5_sp16s_t(qp, pp[14:4]);
	// f = p.Z*q.Z
	f = __mul5_rp16s_z(qp, pp[10:4]);
	
	// f,h = 2*p.Z*q.Z
	cf, f[0] += f[0];
  for i=1 to 5
  { cf, f[i] += f[i] + cf; }
  h = #copy(f);
  
  // f = 2*p.Z*q.Z + 2 * d * q.T * p.T
  t[4:4] = __sub5_srs(f, cs5);
  // h = 2*p.Z*q.Z - 2 * d * q.T * p.T
	t[12:4] = __add5_srs(h, cs5);

	return t;
}

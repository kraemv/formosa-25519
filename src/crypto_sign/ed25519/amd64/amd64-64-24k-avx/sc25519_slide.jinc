#[sct="transient * { ptr: public, val: { n: public, s: transient } } * public * msf -> { ptr: public, val: { n: public, s: transient } } * msf"]
fn sc25519_slide(reg u64[4] s, reg ptr u8[256] r, reg u64 swindowsize, #msf reg u64 msf) -> reg ptr u8[256], #msf reg u64
{
	reg u16 c_2 inv_val neg_val new_val new_window state state_01;
	reg bool cond s1 s2 zf;
	reg u64 _1r addr b curr i z;
	stack u64[4] s_st;
	inline int j;
	
	swindowsize -= 1;
	
	s_st = #copy(s);
	
	state = 2;
	?{}, new_window = #set0_16();
	?{}, addr = #set0();
	b = #LEA(swindowsize + 1);
	?{}, i = #set0();
	_1r = 1;
	?{}, z = #set0();
	for j=1 to 5
	{
		curr = s_st[j-1];
		curr = #protect(curr, msf);
		while{cond=(i < 64*j);}(cond){
			msf = #update_msf(cond, msf);
			
			new_val = (16u)curr;
			new_val &= 1;
			inv_val = new_val;
			
			c_2 = #LEA_16(2 + new_val);
			
			?{}, new_val = #SHL_16(new_val, (8u)b);
			neg_val = new_val;
			neg_val = -neg_val;
			
			// Set state to 1 on critical bit
			?{"==" = s1, ">u" = s2} = #CMP(b, swindowsize);
			new_val = #CMOVcc_16(s2, (16u)z, new_val);
			new_val = #CMOVcc_16(s1, neg_val, new_val);
			state = #CMOVcc_16(s1, c_2, state);
			new_window = #LEA_16(new_window + new_val);
			
			// XOR in state 4, otherwise set to 0 anyways
			state_01 = state;
			state_01 = state_01 >> 1;
			inv_val ^= state;
			?{ ZF = zf }, inv_val = #AND_16(inv_val, state_01);
			r[i] = inv_val;
			
			// Write updated value to the target
			r[addr] = new_window;
			b = #LEA(b + 1);
			
			// State 0 setup (jump to state 1 immidiatly)
			b = #CMOVcc(!zf, _1r, b);
			new_window = #CMOVcc_16(!zf, (16u)_1r, new_window);
			state = #CMOVcc_16(!zf, z, state);
			addr = #CMOVcc(!zf, i, addr);
			
			curr = curr >> 1;
			i = #LEA(i + 1);
		}
		msf = #update_msf(!cond, msf);
	}
	
	return r, msf;
}

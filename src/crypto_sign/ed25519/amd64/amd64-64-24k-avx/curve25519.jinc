require "../common/64/add4.jinc"
require "../common/64/sub4.jinc"

require "mul4.jinc"
require "ge.jinc"
require "invert4.jinc"
require "fe25519_cmov.jinc"
require "fe25519_freeze.jinc"
require "sc25519_from32bytes.jinc"

/**
 * function _curve25519_mulx_base
 * @param {reg u64[4]} k - scalar in 64-bit limb representation
 * @returns {reg u64[4]} - Compressed representation of k*G
 * 
 * This function computes the k-multiple of the basepoint G and
 * outputs the result in compressed representation.
*/
fn _curve25519_mulx_base(reg u64[4] _k, #msf reg u64 msf) -> reg u64[4], #msf reg u64
{
	reg u64 temp par wantmont;
	reg u64[4] r;
	reg u64[4] ZplusY ZminusY rx ry rz;
	stack u64 wantmonts;
	stack u64[4] rxs rys rzs;
	stack u64[16] ger;
	#mmx reg u64 msf_s;
	
	// Make space for branchless computations
	msf_s = #mov_msf(msf);
  
  // Reduce _k below curve order L
  _k = sc25519_from32bytes(_k);
  wantmont = _k[3];
  wantmont = wantmont >> 63;
  wantmonts = wantmont;
  _k[3] &= mask63;
  
  // Compute _k * G, result is one point
  msf = #mov_msf(msf_s);
  ger, msf = __ge25519_scalarmult_base(ger, _k, msf);
  msf_s = #mov_msf(msf);
  
	ry[0] = ger[0];
	ry[1] = ger[1];
	ry[2] = ger[2];
	ry[3] = ger[3];
	
	ZplusY = __add4_rrs(ry, ger[8:4]);
	ZminusY = __sub4_rsr(ger[8:4], ry);
	rys = __cmov4_ssrs(ger[4:4], ZplusY, wantmonts);
	rz = __cmov4_rsrs(ger[8:4], ZminusY, wantmonts);
	
	// Invert z coordinate for point compression
	msf = #mov_msf(msf_s);
	rz, msf = __invert4(rz, msf);
  msf_s = #mov_msf(msf);
  
	rzs = #copy(rz);
	
	// Multiply x,y be z^{-1} for (x,y) representation
	rys = __mul4_ssr(rys, rz);
	
	rx = __mul4_rss(ger[0:4], rzs);
  rxs = __freeze4_sr(rx);
  
  // Reduce y below p
	ry = #copy(rys);
	r = __fe25519_pack(ry);
  
  par = rxs[0];
  par &= 0x1;
  
  temp = 1;
  temp -= wantmonts;
  
  par &= temp;
  par = par << 63;
  r[3] ^= par;
	
	msf = #mov_msf(msf_s);
  return r, msf;
}

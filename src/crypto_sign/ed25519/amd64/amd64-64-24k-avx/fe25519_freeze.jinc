/**
 * function __freeze4_rr
 * @param {reg u64[4]} r - Field element in 64-bit limb representation
 * @returns {reg u64[4]} - Reduced field element in 64-bit limb representation
 * 
 * This function reduces the input r below the prime p. The input is consumed.
*/
inline fn __freeze4_rr(reg u64[4] r) -> reg u64[4]
{
  reg u64[4] t; // Copies of input
  reg u64 two63;  // 1<<63
  reg bool cf;    // Carry flag
  inline int i;

  // Copy input
  t = #copy(r);
  // Set two63 to 1<<63
  two63 = 0x8000000000000000;

  /*
  Add 2^255+19 to t
  If cf=1 -> r < p, r is unchanged
  If cf=1 -> r > p, hence r+2^255+19-2^256=r-2^255+19=r-(2^255-19)
  */
  cf, t[0] += 19;
  cf, t[1] += 0 + cf;
  cf, t[2] += 0 + cf;
  cf, t[3] += two63 + cf;

  for i=0 to 4
  {
    r[i] = #CMOVcc(cf, t[i], r[i]);
  }

  // Same reduction as above
  t = #copy(r);

  cf, t[0] += 19;
  cf, t[1] += 0 + cf;
  cf, t[2] += 0 + cf;
  cf, t[3] += two63 + cf;

  for i=0 to 4
  {
	    r[i] = #CMOVcc(cf, t[i], r[i]);
  }

  // r < p, input can be at most x + 2p in 256 bits
  return r;
}

/**
 * function __freeze4_sr
 * @param {reg u64[4]} r - Field element in 64-bit limb representation
 * @returns {stack u64[4]} - Ptr to reduced field element in 64-bit limb representation
 * 
 * This function reduces the input r below the prime p. The input is unchanged.
*/
inline fn __freeze4_sr(reg u64[4] r) -> stack u64[4]
{
  stack u64[4] h;

  r = __freeze4_rr(r);
  h = #copy(r);

  return h;
}

require "shared_const.jinc"

require "../common/64/add4.jinc"
require "../common/64/add5.jinc"
require "../common/64/sub4.jinc"
require "../common/64/sub5.jinc"

require "mul5.jinc"

/**
 * function ge25519_pnielsadd_p1p1
 * @param {stack u64[18]} pp - Point in extended representation
 * @param {reg ptr u64[16]} qp - Pointer to point in projective representation
 * @returns {stack u64[16]} - Result point in extended intermediate representation
 * 
 * This function computes p+q. The first input is in extended coordinates(x,y,z,t).
 * x,y are 5 limbs large. The second input is in projective niels coordinates(y-x,x+y,z,t*2*d).
 * The output is in extended intermediate coordinates (e,f,g,h).
 * e = (p.Y + p.X) * (q.Y - q.X) - (p.Y - p.X) * (q.X + q.Y)
 * f = 2*p.Z*q.Z + 2 * d * q.T * p.T
 * g = (p.Y + p.X) * (q.Y - q.X) + (p.Y - p.X) * (q.X + q.Y)
 * h = 2*p.Z*q.Z - 2 * d * q.T * p.T
*/
inline fn ge25519_pnielsadd_p1p1(stack u64[18] pp, reg ptr u64[16] qp) -> stack u64[16]
{
	reg u64[5] a b e f g h;
	stack u64[4] as bs;
	stack u64[5] as5 cs5;
	stack u64[16] t;
	reg bool cf;
	inline int i;
	
	// a,b = p.Y
	for i=0 to 5
	{	a[i] = pp[5+i]; }
	b = #copy(a);
	
	// a = p.Y - p.X
	as = __sub5_srs(a, pp[0:5]);
	// b = p.Y + p.X
	bs = __add5_srs(b, pp[0:5]);
	
	// a = (p.Y - p.X) * (q.Y - q.X)
	as5 = __mul5_sp16s_x(qp, as);
	// b,c = (p.Y + p.X) * (q.Y + q.X)
	e = __mul5_rp16s_y(qp, bs);
	g = #copy(e);
	
	// e = (p.Y + p.X) * (q.Y + q.X) - (p.Y - p.X) * (q.Y - q.X)
	t[0:4] = __sub5_srs(e, as5);
	// g = (p.Y + p.X) * (q.Y + q.X) + (p.Y - p.X) * (q.Y - q.X)
	t[8:4] = __add5_srs(g, as5);
	
	// c = 2 * d * q.T * p.T
	cs5 = __mul5_sp16s_t(qp, pp[14:4]);
	// f = p.Z*q.Z
	f = __mul5_rp16s_z(qp, pp[10:4]);
	
	// f,h = 2*p.Z*q.Z
	cf, f[0] += f[0];
  for i=1 to 5
  { cf, f[i] += f[i] + cf; }
  h = #copy(f);
  
  // f = 2*p.Z*q.Z + 2 * d * q.T * p.T
  t[4:4] = __add5_srs(f, cs5);
  // h = 2*p.Z*q.Z - 2 * d * q.T * p.T
  t[12:4] = __sub5_srs(h, cs5);
	
	return t;
}

/**
 * function ge25519_pnielsadd_p1p1_prep
 * @param {stack u64[18]} pp - Point in extended representation
 * @param {reg ptr u64[16]} qp - Pointer to point in projective representation
 * @returns {reg ptr u64[16]} - Result point in extended representation
 * 
 * This function computes p+q. The first input is in extended coordinates(x,y,z,t).
 * x,y are 5 limbs large. The second input is in projective niels coordinates(y-x,x+y,z,t*2*d).
 * The output is in extended coordinates (x,y,z,t).
*/
inline fn ge25519_pnielsadd_p1p1_prep(reg mut ptr u64[16] rp, stack u64[18] pp, reg ptr u64[16] qp) -> reg mut ptr u64[16]
{
	reg u64[4] ysubx xaddy z t2d;
	reg u64[5] xaddy5 _xaddy5 ysubx5;
	stack u64[4] t2ds;
	stack u64[5] xaddy5s;
	stack u64[16] t;
	inline int i;
	
	() = #spill(rp);
	
	// Compute intermediate coordinates of p+q
	t = ge25519_pnielsadd_p1p1(pp, qp);
	
	// t = e*g
	t2ds = __mul4_sss(t[0:4], t[8:4]);
	// y = f*g
	xaddy5s = __mul5_sss(t[4:4], t[8:4]);
	// x = e*h
	ysubx5  = __mul5_rss(t[0:4], t[12:4]);
	
	xaddy5 = #copy(xaddy5s);
	_xaddy5 = #copy(xaddy5);
	// ysubx = y-x
	ysubx = __sub5_rrr(xaddy5, ysubx5);
	() = #unspill(rp);
	for i=0 to 4{
		rp[i] = ysubx[i];
	}
	// xaddy = x+y
	xaddy = __add5_rrr(_xaddy5, ysubx5);
	for i=0 to 4{
		rp[4+i] = xaddy[i];
	}
	
	// z = f*h
	z = __mul4_rss(t[4:4], t[12:4]);
	for i=0 to 4{
  		rp[8+i] = z[i];
  }
  
  // t2d = 2*d*t
	t2d = __mul4_rss(ec2d, t2ds);
	for i=0 to 4{
		rp[12+i] = t2d[i];
	}
  
  return rp;
}

require "shared_const.jinc"

require "../common/load_ptr4.jinc"
require "../common/64/add4.jinc"
require "../common/64/sub4.jinc"
require "../common/64/add5.jinc"
require "../common/64/sub5.jinc"

require "neg.jinc"
require "mul4.jinc"
require "sqr4.jinc"

/**
 * function ge25519_dbl_p1p1
 * @param {reg ptr u64[12]} pp - Point in projective representation
 * @returns {stack u64[16]} - Result point in extended representation
 * 
 * This function computes 2*pp. The input is in projective coordinates(x,y,z).
 * The output is in intermediate extended coordinates(e,f,g,h).
 * e= 2*x*y
 * f= -x^2 + y^2
 * g= -y^2 - x^2
 * h= -x^2 + y^2 - 2*z^2
*/
inline fn ge25519_dbl_p1p1(reg ptr u64[12] pp) -> stack u64[16]
{
	reg u64[5] a b c d e;
	reg u64[4] d4 e4;
	stack u64[5] as bs cs;
	stack u64[16] r;				// Result
	reg bool cf;						// Carry flag
	inline int i;
	
	// a = z^2
	a = __sqr5_rp(pp[8:4]);
	
	// a = 2*z^2
	cf, a[0] += a[0];
	for i=1 to 5
	{ cf, a[i] += a[i] + cf; }
	as = #copy(a);
	
	// b = y^2
	b = __sqr5_rp(pp[4:4]);
	bs = #copy(b);
	
	// c = x^2
	c = __sqr5_rp(pp[0:4]);
	cs = #copy(c);
	
	// c = -x^2
	c = __neg5_rr(c);
	
	// c,d = -x^2 + y^2
	// c=__add5_rrs(c, bs),
	// d is unreduced c
	cf, c[0] += bs[0];
  for i=1 to 5
  { cf, c[i] += bs[i] + cf; }
	d = #copy(c);
	
  _, _, _, _, _, c[4] = #SHLD(c[4], c[3], 1);
  c[3] &= mask63;
	
	_,_,_,_,_,c[4] = #IMULri ( c[4], 19 );
	cf, c[0] = c[0] + c[4];
	cf, c[1] = c[1] + 0 + cf;
	cf, c[2] = c[2] + 0 + cf;
	_ , c[3] = c[3] + 0 + cf;
	
	// f = -x^2 + y^2
	for i=0 to 4
	{	r[4+i] = c[i]; }
	
	// h = -x^2 + y^2 - 2*z^2
	r[12:4] = __sub5_srs_nored(d, as);
	
	// b = -y^2
	b = __neg5_rs(bs);
	
	// g = -y^2 - x^2
	d4 = __sub5_rrs(b, cs);
	r[8:4] = #copy(d4);
	
	// e = x + y
	e4 = __add4_rss(pp[0:4], pp[4:4]);
	
	// e = (x + y)^2
	e = __sqr5_rr(e4);
	
	// e = (x + y)^2 -y^2 - x^2 = 2*x*y
	e4 = __add54_rrs(e, r[8:4]);
	r[0:4] = #copy(e4);
	
	return r;
}

/**
 * function ge25519_dbl_p1p1
 * @param {reg ptr u64[12]} pp - Point in projective representation
 * @returns {stack u64[16]} - Result point in extended representation
 * @returns {reg ptr u64[12]} - Input in niels representation
 * 
 * This function computes 2*pp. The input is in projective coordinates(x,y,z).
 * The first output is in intermediate extended coordinates(e,f,g,h).
 * e= 2*x*y
 * f= -x^2 + y^2
 * g= -y^2 - x^2
 * h= -x^2 + y^2 - 2*z^2
 * The second output is the niels representation of the input
 * ysubx= x-y
 * xaddy= x+y
*/
inline fn ge25519_dbl_p1p1_prep(reg ptr u64[12] pp) -> stack u64[16], reg ptr u64[12]
{
	reg u64[4] d4 e4 x _y y;
	reg u64[5] a b c e;
	stack u64[5] as bs;
	stack u64[16] r;
	reg ptr u64[4] p_ptr;
	reg bool cf;
	inline int i;
	
	// b = y^2
	b = __sqr5_rp(pp[4:4]);
	bs = #copy(b);
	
	// a = x^2
	a = __sqr5_rp(pp[0:4]);
	as = #copy(a);
	
	// a = -x^2
	a = __neg5_rr(a);
	
	// c,f = -x^2 + y^2
	// a=__add5_rrs(a, bs),
	// c is unreduced a
	cf, a[0] += bs[0];
  for i=1 to 5
  { cf, a[i] += bs[i] + cf; }
	c = #copy(a);
	
  _, _, _, _, _, a[4] = #SHLD(a[4], a[3], 1);
  a[3] &= mask63;
	
	_,_,_,_,_,a[4] = #IMULri ( a[4], 19 );
	cf, a[0] = a[0] + a[4];
	cf, a[1] = a[1] + 0 + cf;
	cf, a[2] = a[2] + 0 + cf;
	_ , a[3] = a[3] + 0 + cf;
	for i=0 to 4
	{	r[4+i] = a[i]; }
	
	// Subtract 2*z, and z=1 at point init
	// h = -x^2 + y^2 - 2*(z=1)
	r[12:4] = __subi5_sri(c, 2);
	
	// b = -y^2
	b = __neg5_rs(bs);
	
	// g = -y^2 - x^2
	d4 = __sub5_rrs(b, as);
	r[8:4] = #copy(d4);
	
	// Prepare pre[0]
	x = __load_ptr4(pp[0:4]);
	y = __load_ptr4(pp[4:4]);
	_y = #copy(y);
	
	// ysubx = y-x
	pp[0:4] = __sub4_srr(y, x);
	// xaddy = x+y
	pp[4:4] = __add4_srr(_y, x);
	
	// e = (x+y)^2
	p_ptr = pp[4:4];
	e = __sqr5_rp(p_ptr);
	
	// e = (x+y)^2 - x^2 - y^2 = 2*x*y
	e4 = __add54_rrs(e, r[8:4]);
	r[0:4] = #copy(e4);
	
	return r, pp;
}
